#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout (local_size_x = 1, local_size_y = 1) in;

//layout (binding = 0, r32f) uniform writeonly image1D RWImage;
layout (set = 0, binding = 0) buffer IB
{
	int OutIndices[];
};

struct FPosColorUVVertex
{
	float x, y, z;
	uint Color;
	float u, v;
};

layout (set = 0, binding = 1) buffer VB
{
	FPosColorUVVertex OutVertices[];
};

layout (set = 0, binding = 2) uniform UB
{
	float Y;
	float Extent;
	int NumQuadsX;
	float Elevation;
};

layout(set = 0, binding = 3) uniform sampler2D Heightmap;

void main()
{
	int QuadIndex = int(gl_GlobalInvocationID.x);

	if (QuadIndex < NumQuadsX)
	{
		OutIndices[QuadIndex * 6 + 0] = QuadIndex * 4 + 0;
		OutIndices[QuadIndex * 6 + 1] = QuadIndex * 4 + 1;
		OutIndices[QuadIndex * 6 + 2] = QuadIndex * 4 + 3;
		OutIndices[QuadIndex * 6 + 3] = QuadIndex * 4 + 1;
		OutIndices[QuadIndex * 6 + 4] = QuadIndex * 4 + 2;
		OutIndices[QuadIndex * 6 + 5] = QuadIndex * 4 + 3;

		float Width = 2.0 * Extent;
		float WidthPerQuad = Width / float(NumQuadsX);
		float X0 = -Extent + WidthPerQuad * float(QuadIndex);
		float UWidth = 1.0 / float(NumQuadsX);
		float U0 = UWidth * float(QuadIndex);

		float CurrentHeight = texture(Heightmap, vec2(U0, 0.0)).x;
		float NextHeight = texture(Heightmap, vec2(U0 + UWidth, 0.0)).x;

		OutVertices[QuadIndex * 4 + 0].x = X0;
		OutVertices[QuadIndex * 4 + 0].y = Y + CurrentHeight * Elevation;
		OutVertices[QuadIndex * 4 + 0].z = -Extent;
		OutVertices[QuadIndex * 4 + 0].Color = uint(-1);
		OutVertices[QuadIndex * 4 + 0].u = U0;
		OutVertices[QuadIndex * 4 + 0].v = 0;

		OutVertices[QuadIndex * 4 + 1].x = X0 + WidthPerQuad;
		OutVertices[QuadIndex * 4 + 1].y = Y + NextHeight * Elevation;
		OutVertices[QuadIndex * 4 + 1].z = -Extent;
		OutVertices[QuadIndex * 4 + 1].Color = uint(-1);
		OutVertices[QuadIndex * 4 + 1].u = U0 + UWidth;
		OutVertices[QuadIndex * 4 + 1].v = 0;

		OutVertices[QuadIndex * 4 + 2].x = X0 + WidthPerQuad;
		OutVertices[QuadIndex * 4 + 2].y = Y + NextHeight * Elevation;
		OutVertices[QuadIndex * 4 + 2].z = Extent;
		OutVertices[QuadIndex * 4 + 2].Color = uint(-1);
		OutVertices[QuadIndex * 4 + 2].u = U0 + UWidth;
		OutVertices[QuadIndex * 4 + 2].v = 1;

		OutVertices[QuadIndex * 4 + 3].x = X0;
		OutVertices[QuadIndex * 4 + 3].y = Y + CurrentHeight * Elevation;
		OutVertices[QuadIndex * 4 + 3].z = Extent;
		OutVertices[QuadIndex * 4 + 3].Color = uint(-1);
		OutVertices[QuadIndex * 4 + 3].u = U0;
		OutVertices[QuadIndex * 4 + 3].v = 1;
	}
}
