#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout (local_size_x = 1, local_size_y = 1) in;

//layout (binding = 0, r32f) uniform writeonly image1D RWImage;
layout (set = 0, binding = 0) buffer IB
{
	int OutIndices[];
};

struct FPosColorUVVertex
{
	float x, y, z;
	uint Color;
	float u, v;
};

layout (set = 0, binding = 1) buffer VB
{
	FPosColorUVVertex OutVertices[];
};

layout (set = 0, binding = 2) uniform UB
{
	float Y;
	float Extent;
	int NumQuadsX;
	float Elevation;
};

layout(set = 0, binding = 3) uniform sampler2D Heightmap;

void main()
{
	int QuadIndex = int(gl_GlobalInvocationID.x);

	if (QuadIndex < NumQuadsX)
	{
		OutIndices[QuadIndex * 6 + 0] = QuadIndex * 4 + 0;
		OutIndices[QuadIndex * 6 + 1] = QuadIndex * 4 + 1;
		OutIndices[QuadIndex * 6 + 2] = QuadIndex * 4 + 3;
		OutIndices[QuadIndex * 6 + 3] = QuadIndex * 4 + 1;
		OutIndices[QuadIndex * 6 + 4] = QuadIndex * 4 + 2;
		OutIndices[QuadIndex * 6 + 5] = QuadIndex * 4 + 3;

		float Width = 2.0 * Extent;
		float WidthPerQuadX = Width / float(NumQuadsX);
		float WidthPerQuadZ = Width;
		float X0 = -Extent + WidthPerQuadX * float(QuadIndex);
		float UWidth = 1.0 / float(NumQuadsX);
		float U0 = UWidth * float(QuadIndex);
		float VWidth = 1.0;
		float V0 = 0.0;
		float Z0 = -Extent;

		float CurrentHeight = texture(Heightmap, vec2(U0, V0)).x;
		float NextHeight = texture(Heightmap, vec2(U0 + UWidth, V0 + VWidth)).x;
		float Y0 = Y + Elevation * CurrentHeight;
		float Y1 = Y + Elevation * NextHeight;

		OutVertices[QuadIndex * 4 + 0].x = X0;
		OutVertices[QuadIndex * 4 + 0].y = Y0;
		OutVertices[QuadIndex * 4 + 0].z = Z0;
		OutVertices[QuadIndex * 4 + 0].Color = uint(-1);
		OutVertices[QuadIndex * 4 + 0].u = U0;
		OutVertices[QuadIndex * 4 + 0].v = V0;

		OutVertices[QuadIndex * 4 + 1].x = X0 + WidthPerQuadX;
		OutVertices[QuadIndex * 4 + 1].y = Y1;
		OutVertices[QuadIndex * 4 + 1].z = Z0;
		OutVertices[QuadIndex * 4 + 1].Color = uint(-1);
		OutVertices[QuadIndex * 4 + 1].u = U0 + UWidth;
		OutVertices[QuadIndex * 4 + 1].v = V0;

		OutVertices[QuadIndex * 4 + 2].x = X0 + WidthPerQuadX;
		OutVertices[QuadIndex * 4 + 2].y = Y1;
		OutVertices[QuadIndex * 4 + 2].z = Z0 + WidthPerQuadZ;
		OutVertices[QuadIndex * 4 + 2].Color = uint(-1);
		OutVertices[QuadIndex * 4 + 2].u = U0 + UWidth;
		OutVertices[QuadIndex * 4 + 2].v = V0 + VWidth;

		OutVertices[QuadIndex * 4 + 3].x = X0;
		OutVertices[QuadIndex * 4 + 3].y = Y0;
		OutVertices[QuadIndex * 4 + 3].z = Z0 + WidthPerQuadZ;
		OutVertices[QuadIndex * 4 + 3].Color = uint(-1);
		OutVertices[QuadIndex * 4 + 3].u = U0;
		OutVertices[QuadIndex * 4 + 3].v = V0 + VWidth;
	}
}
